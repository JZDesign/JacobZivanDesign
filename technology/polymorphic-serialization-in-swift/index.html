<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Jacob Zivan Design"/><link rel="canonical" href="https://JacobZivanDesign.com/technology/polymorphic-serialization-in-swift"/><meta name="twitter:url" content="https://JacobZivanDesign.com/technology/polymorphic-serialization-in-swift"/><meta name="og:url" content="https://JacobZivanDesign.com/technology/polymorphic-serialization-in-swift"/><title>Polymorphic Serialization in Swift | Jacob Zivan Design</title><meta name="twitter:title" content="Polymorphic Serialization in Swift | Jacob Zivan Design"/><meta name="og:title" content="Polymorphic Serialization in Swift | Jacob Zivan Design"/><meta name="description" content="Learn how to use Codable enum's in Swift to handle Polymorphic Serialization."/><meta name="twitter:description" content="Learn how to use Codable enum's in Swift to handle Polymorphic Serialization."/><meta name="og:description" content="Learn how to use Codable enum's in Swift to handle Polymorphic Serialization."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Jacob Zivan Design"/><meta name="twitter:image" content="https://JacobZivanDesign.com/images/social.jpg"/><meta name="og:image" content="https://JacobZivanDesign.com/images/social.jpg"/></head><body class="item-page"><!--ITEM HTML--><header><div class="wrapper"><a class="site-icon" href="/"><img src="/images/memoji.png" alt="Memoji of Jacob giving a thumbs up"/></a><nav><ul><li><a href="/musings">Musings</a></li><li><a class="selected" href="/technology">Technology</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Polymorphic Serialization in Swift</h1><p>Before I show you how to use enumerations to handle polymorphic serialization in Swift, I'm going to explain a few things. After defining some terms and giving examples we'll get into it.</p><h2>What is Serialization?</h2><p>Serialization is one of the most common things I have to handle in my role as a software engineer. It is simple usually. The serialization I'm referring to is the mapping of JSON into your model object in whatever language you're using.</p><p>Let's take this JSON for example:</p><pre><code>{
    <span class="string">"item_name"</span> : <span class="string">"potion"</span>
}
</code></pre><p>When we make the request to the server and get that data back from the web, we'd generally like to use a struct that represents an Item like:</p><pre><code><span class="keyword">struct</span> Item {
    <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre><p>Serialization does just that. To do it in swift, we use a protocol named <a href="https://developer.apple.com/documentation/swift/codable"><code>Codable</code></a>.</p><br/><h2>Codable</h2><p>This protocol handles the heavy lifting for us. Generally all we need to do is make the structure conform to the protocol. Like so:</p><pre><code><span class="keyword">struct</span> Item: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre><p>Just by adding <code>: Codable</code> to the structure declaration, swift will be able to <a href="https://developer.apple.com/documentation/swift/encodable/2893603-encode">encode</a> or <a href="https://developer.apple.com/documentation/swift/decodable/2894081-init">decode</a> <em>(AKA serialize)</em> the model. However, the JSON this particular model would expect to decode <em>(or would produce by encoding)</em> looks like:</p><pre><code>{
    <span class="string">"name"</span>: <span class="string">"potion"</span>
}
</code></pre><p>Did you notice the difference, <code>"name"</code> instead of <code>"item_name"</code>? Swift automatically takes the name of the variable and encodes that as the JSON key. I'd like to use <code>Item.name</code> as the syntax in my Swift project instead of <code>Item.item_name</code>. To show you how to do that let's take a look at Coding Keys.</p><br/><h2>Coding Keys</h2><p>Coding keys are an enumeration we can use to override Swift's default serialization of the keys. Let's go back to item and add a couple of things:</p><pre><code><span class="keyword">struct</span> Item: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> weight: <span class="type">Decimal</span>
    <span class="keyword">let</span> description: <span class="type">String</span>

    <span class="keyword">enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> name = <span class="string">"item_name"</span>
        <span class="keyword">case</span> weight, description
    }
}
</code></pre><p>In this example, we overrode the <code>name</code> to have a different coding key, but we left the other 2 alone. This means that we could receive JSON that looks like this:</p><pre><code>{
    <span class="string">"item_name"</span>: <span class="string">"Potion"</span>,
    <span class="string">"weight"</span>: <span class="number">1.22</span>,
    <span class="string">"description"</span>: <span class="string">"A generic health potion."</span>
}
</code></pre><p>Great! Now you know how to serialize JSON into a specific type. It's a great start. However, there are some instances where you'll get a dynamic set of data for a given key in the JSON. And this won't help you there. Instead, we would need to create a way for our application to recognize different kinds of items and have a dynamic model to represent the JSON.</p><br/><h2>Polymorphic Serialization</h2><p>Let's say that our API is responsible for managing the inventory of our players. It sends back an array of items. Those items can be different types: Weapons, Armor, Potions, Misc, etc.,</p><p>Weapons and armor are 2 different items that one could expect to see in many video games. They are dramatically different things, and as such, they aren't represented the same way in the JSON. Let's take a look at the following example.</p><pre><code>{
    <span class="string">"backpack"</span>: [
        {
            <span class="string">"name"</span>: <span class="string">"Leather"</span>,
            <span class="string">"armor_class"</span>: <span class="number">1.2</span>,
            <span class="string">"description"</span>: <span class="string">"Basic Leather Armor"</span>
        },
        {
            <span class="string">"name"</span>: <span class="string">"Short Sword"</span>,
            <span class="string">"ranged"</span>: <span class="keyword">false</span>,
            <span class="string">"description"</span>: <span class="string">"Basic Short Sword"</span>,
            <span class="string">"damage_type"</span>: <span class="string">"Slashing"</span>,
            <span class="string">"damage_modifier"</span>: <span class="number">1.1</span>
        }
    ]
}
</code></pre><p>See the difference? The first <code>Item</code> in the array is a piece of <code>Armor</code>, the second is a <code>Weapon</code>. Since Swift is statically typed, this can be difficult to represent by a single model without making most fields optional. When I was newer to the craft, I would do that. I used to create a single <code>Item</code> model with every possible field represented and most of them would be optional. Something like:</p><pre><code><span class="keyword">struct</span> Item: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> ranged: <span class="type">Bool</span>?
    <span class="keyword">let</span> description: <span class="type">String</span>?
    <span class="keyword">let</span> damageType: <span class="type">String</span>?
    <span class="keyword">let</span> armorClass: <span class="type">Decimal</span>?
    <span class="keyword">let</span> damageModifier: <span class="type">Decimal</span>?
}

<span class="keyword">struct</span> Inventory: <span class="type">Codable</span> {
    <span class="keyword">let</span> backpack: [<span class="type">Item</span>]
}
</code></pre><p>With the <code>Item</code> model shown above, I would have to inspect the structure for specific bits of data to know if it was a weapon, a piece of armor, or a potion. Then I would need to unwrap those fields as I needed to use them. This is a big pain in the rear. Don't do it.</p><blockquote><p>Don't do it.</p></blockquote><p>Polymorphic serialization is the process of making the model statically represent the different JSON objects. To do that in Swift we'll use an enumeration.</p><br/><h3>Enumerations with Associated Values</h3><br/><p>Swift <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html">Enumerations</a> are quite powerful. One of my favorite features by far is the <a href="https://www.swiftbysundell.com/tips/default-enum-associated-values/">Associated Value</a>. This is somewhat advanced. It allows us to define a set of values <em>(the enum)</em> that are always the same, but then inject other values into the enumeration <em>(the associated value)</em>. It looks like this:</p><pre><code><span class="keyword">enum</span> Result&lt;T&gt; {
    <span class="keyword">case</span> success(<span class="type">T</span>)
    <span class="keyword">case</span> failure(<span class="type">Error</span>)
}
</code></pre><p>If you're used to Swift, you've seen this enumeration before. To use it we have to inject values into <em>(and extract the value from)</em> the enumeration. Here are some examples on how that works:</p><pre><code><span class="keyword">func</span> doSomething(with thing: <span class="type">Int</span>?) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; {
    <span class="keyword">guard let</span> anotherThing = thing <span class="keyword">else</span> {
        <span class="keyword">return</span> .<span class="call">failure</span>(<span class="type">NilIntError</span>())
    }
    <span class="keyword">return</span> .<span class="call">success</span>(anotherThing)
}

<span class="keyword">func</span> handle(optional: <span class="type">Int</span>?) {
    <span class="keyword">switch</span> doSomething(with: optional) {
    <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> value):
        <span class="call">print</span>(value)
    <span class="keyword">case</span> .<span class="dotAccess">error</span>(<span class="keyword">let</span> error):
        <span class="call">print</span>(error)
    }
}
</code></pre><p>Notice how we can only create the 2 values of the enumeration <code>success</code> and <code>failure</code> but we can put so much more information inside of them!?</p><p>We're going to define our own enumeration with associated values in a minute. Before we get there though, let's create 2 different item types that are represented in the JSON response from the Inventory API.</p><br/><h3>Weapons and Armor</h3><br/><p>The <code>Item</code> we made before that was used in the <code>Inventory</code> struct wouldn't handle the backpack JSON above very well. Instead <code>Item</code> will need to be an enum with the kinds of items that could be represented inside.</p><p>Let's create the models:</p><pre><code><span class="keyword">struct</span> Armor: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> armorClass: <span class="type">Decimal</span>
    <span class="keyword">let</span> description: <span class="type">String</span>

    <span class="keyword">enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> name, description
        <span class="keyword">case</span> armorClass = <span class="string">"armor_class"</span>
    }
}

<span class="keyword">struct</span> Weapon: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> ranged: <span class="type">Bool</span>
    <span class="keyword">let</span> description: <span class="type">String</span>
    <span class="keyword">let</span> damageType: <span class="type">String</span>
    <span class="keyword">let</span> damageModifier: <span class="type">Decimal</span>

    <span class="keyword">enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> name, ranged, description
        <span class="keyword">case</span> damageType = <span class="string">"damage_type"</span>
        <span class="keyword">case</span> damageModifier = <span class="string">"damage_modifier"</span>
    }
}

<span class="keyword">enum</span> Item: <span class="type">Codable</span> {
    <span class="keyword">case</span> weapon(<span class="type">Weapon</span>)
    <span class="keyword">case</span> armor(<span class="type">Armor</span>)
}
</code></pre><p>This is looking better. However, if you try to serialize this, you'll get failures. The system doesn't know which enumeration value to select because <code>.weapon</code> and <code>.armor</code> aren't raw types like String or Int at the top level, the objects being serialized are nested within the enumeration. We need to provide a little more detail for Swift to encode or decode into this enum. To do so, we'll add the <code>Encodable</code> function and <code>Decodable</code> initializer.</p><pre><code><span class="keyword">enum</span> Item: <span class="type">Codable</span> {
    <span class="keyword">case</span> weapon(<span class="type">Weapon</span>)
    <span class="keyword">case</span> armor(<span class="type">Armor</span>)

    <span class="keyword">init</span> (from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">if let</span> weapon = <span class="keyword">try</span>? <span class="type">Weapon</span>(from: decoder) {
            <span class="keyword">self</span> = .<span class="call">weapon</span>(weapon)
        } <span class="keyword">else if let</span> armor = <span class="keyword">try</span>? <span class="type">Armor</span>(from: decoder) {
            <span class="keyword">self</span> = .<span class="call">armor</span>(armor)
        } <span class="keyword">else</span> {
            <span class="keyword">self</span>.<span class="keyword">init</span>(from: decoder) <span class="comment">// this will fail!</span>
        }
    }

    <span class="keyword">func</span> encode(to encoder: <span class="type">Encoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">armor</span>(<span class="keyword">let</span> armor):
            <span class="keyword">try</span> armor.<span class="call">encode</span>(to: encoder)
        <span class="keyword">case</span> .<span class="dotAccess">weapon</span>(<span class="keyword">let</span> weapon):
            <span class="keyword">try</span> weapon.<span class="call">encode</span>(to: encoder)
        }
    }
}
</code></pre><br/><h1>🔥☝️</h1><p>That little bit of code handles quite a lot! In the initializer we're attempting to create the types that we care about, in the <code>else</code> block we're forcing a failure. You could choose to swallow the mismatched item instead <em>(perhaps log it)</em> until you add that model too. That's really all it takes to create a polymorphic serializer in Swift!</p></div><span>Tags: </span><ul class="tag-list"><li><a href="/tags/macos">MacOS</a></li><li><a href="/tags/ios">iOS</a></li><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/technology">Technology</a></li><li><a href="/tags/tutorial">Tutorial</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p class="jbmono">Code typeface == <a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a></p><p><a href="/feed.rss">RSS feed</a></p><div class="social"><a target="_blank" class="find-me" href="https://github.com/JZDesign/"><img src="/images/git.svg"/></a><a target="_blank" class="find-me" href="https://www.linkedin.com/in/jacob-rakidzich-b8722436/"><img src="/images/linkedin.svg"/></a></div></footer></body></html>