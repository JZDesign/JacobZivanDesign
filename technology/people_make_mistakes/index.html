<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Jacob Zivan Design"/><link rel="canonical" href="https://JacobZivanDesign.com/technology/people_make_mistakes"/><meta name="twitter:url" content="https://JacobZivanDesign.com/technology/people_make_mistakes"/><meta name="og:url" content="https://JacobZivanDesign.com/technology/people_make_mistakes"/><title>Humans write code, and humans make mistakes. | Jacob Zivan Design</title><meta name="twitter:title" content="Humans write code, and humans make mistakes. | Jacob Zivan Design"/><meta name="og:title" content="Humans write code, and humans make mistakes. | Jacob Zivan Design"/><meta name="description" content="One thing I've learned is to **just freaking** let the compiler prevent me from making mistakes. Sometimes that's hard to do, then I learned about something called a Domain Primitive and I decided to give it a try in Swift."/><meta name="twitter:description" content="One thing I've learned is to **just freaking** let the compiler prevent me from making mistakes. Sometimes that's hard to do, then I learned about something called a Domain Primitive and I decided to give it a try in Swift."/><meta name="og:description" content="One thing I've learned is to **just freaking** let the compiler prevent me from making mistakes. Sometimes that's hard to do, then I learned about something called a Domain Primitive and I decided to give it a try in Swift."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Jacob Zivan Design"/><meta name="twitter:image" content="https://JacobZivanDesign.com/images/social.jpg"/><meta name="og:image" content="https://JacobZivanDesign.com/images/social.jpg"/></head><body class="item-page"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({ startOnLoad: true });</script><!--ITEM HTML--><header><div class="wrapper"><a class="site-icon" href="/"><img src="/images/memoji.png" alt="Memoji of Jacob giving a thumbs up"/></a><nav><ul><li><a class="selected" href="/technology">Technology</a></li><li><a href="/foresight">Foresight</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Humans write code, and humans make mistakes.</h1><p>In my journey writing software, I've come to love working in strongly typed, compiled languages. If I'm being totally honest, at first… I didn't care for them. They felt restrictive. Why couldn't I just send whatever I wanted and just wrangle it on the other side? In my youthful hubris, I often thought things like: "I'm not dumb, I won't send an object when I need an integer." But, it didn't take long for me to forget the details of what I had worked on, and I wrote the very code I swore I was incapable of writing. And of course, it took longer than I would have liked to figure out what the issue was and get it fixed. Now, I wish I could tell you that I only ever did that once… but I would be lying.</p><p>Events like those, whether it was code I wrote or an inherited bug I had to chase down, are what really drove me into the arms of good compiled languages like Swift or Kotlin. One of their primary benefits is the compiler preventing me from making certain mistakes, and therefore, preventing me from shipping a lot more bugs. However, there is one way this is lacking in our languages today, and that is how often we need to pass around a simple value—think of very commonly used types like: <code>String</code>, <code>Int</code>, <code>Bool</code>—and since they're so common, the compiler doesn't ensure I typed what I meant to. To describe what I mean, consider the following examples:</p><p>If I have a function or a class that needs an Identifier that is represented by a common type like <code>String</code> there is nothing preventing me from providing it the wrong identifier. For example, say we have a Customer object that has an Id. On that object are <code>membershipId</code> and <code>activeOfferId</code> fields that are used to fetch more specific data later. All are of type <code>String</code>. Like this:</p><pre><code><span class="keyword">struct</span> Customer {
    <span class="keyword">let</span> id: <span class="type">String</span>
    <span class="keyword">let</span> membershipId: <span class="type">String</span>
    <span class="keyword">let</span> activeOfferId: <span class="type">String</span>
}
</code></pre><p>That seems fine right now, but the problems arise when we need to call certain functions with this data. Say we have a function that gets some useful object by <code>membershipId</code> but the developer didn't make that very clear. Like:</p><pre><code><span class="keyword">func</span> getUsefulThingForCustomer(by id: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">SomeUsefulThing</span>
</code></pre><p>That reads as if I should send it the <code>customer.id</code>, not the <code>membershipId</code> so at some point we can accidentally swap out the argument and introduce a bug because it reads like it should be a different ID. This happens all the more with functions or initializers that use multiple unnamed arguments of the same type. If the order changes for some reason, nothing enforces that we update the call-sites to match the new order. For example:</p><pre><code><span class="keyword">struct</span> Customer {
    <span class="keyword">let</span> id: <span class="type">String</span>
    <span class="keyword">let</span> membershipId: <span class="type">String</span>
    <span class="keyword">let</span> activeOfferId: <span class="type">String</span>

    <span class="comment">// First version of the function</span>
    <span class="keyword">static func</span> new(<span class="keyword">_</span> id: <span class="type">String</span>, <span class="keyword">_</span> membershipId: <span class="type">String</span>, <span class="keyword">_</span> activeOfferId: <span class="type">String</span>) -&gt; <span class="type">Customer</span>
}
<span class="comment">// It's used in a file like this:</span>
<span class="keyword">let</span> customer = <span class="type">Customer</span>.<span class="call">new</span>(<span class="string">"811E06EC-73C8-45C2-A4CE-AA99E11B05C7"</span>, <span class="string">"membership-1"</span>, <span class="string">"activeOffer-1"</span>)

<span class="comment">// Along the lines, someone decides that the code formatter will enforce all functions should have alphabetically ordered arguments
// Then the `new` function is changed to this:</span>

<span class="keyword">static func</span> new(<span class="keyword">_</span> activeOfferId: <span class="type">String</span>, <span class="keyword">_</span> id: <span class="type">String</span>, <span class="keyword">_</span> membershipId: <span class="type">String</span>) -&gt; <span class="type">Customer</span>

<span class="comment">// but the call site does't get updated… and then you have an interesting bug to track down.</span>
</code></pre><p>You can solve this by creating a custom type that represents the value, but is totally unique. For example:</p><pre><code><span class="keyword">struct</span> CustomerId: <span class="type">RawRepresentable</span> {
    <span class="keyword">let</span> rawValue: <span class="type">UUID</span>
}

<span class="keyword">struct</span> MembershipId: <span class="type">RawRepresentable</span> {
    <span class="keyword">let</span> rawValue: <span class="type">String</span>
}

<span class="keyword">struct</span> ActiveOfferId: <span class="type">RawRepresentable</span> {
    <span class="keyword">let</span> rawValue: <span class="type">String</span>
}

<span class="keyword">struct</span> Customer {
    <span class="keyword">let</span> id: <span class="type">CustomerId</span>
    <span class="keyword">let</span> membershipId: <span class="type">MembershipId</span>
    <span class="keyword">let</span> activeOfferId: <span class="type">ActiveOfferId</span>

    <span class="comment">// First version of the function</span>
    <span class="keyword">static func</span> new(<span class="keyword">_</span> id: <span class="type">CustomerId</span>, <span class="keyword">_</span> membershipId: <span class="type">MembershipId</span>, <span class="keyword">_</span> activeOfferId: <span class="type">ActiveOfferId</span>) -&gt; <span class="type">Customer</span>
}
</code></pre><p>Now, if the formatter went and tried to make the alphabetical ordering change, the compiler would throw an error because the arguments aren't the right types. This is a nice improvement. But it's not all sunshine and rainbows… That <code>RawRepresentable</code> protocol requires you create an object that contains some value, and if that value is more complex than a simple primitive value like <code>Int</code>, <code>Bool</code>, or <code>String</code>… things get interesting when you're serializing the object to and from JSON.</p><p>Before, if you wanted to decode JSON into the <code>Customer</code> type, you would just need to slap the <code>Decodable</code> protocol on the struct and you can ingest JSON that looks like this:</p><pre><code>{
    <span class="string">"id"</span>: <span class="string">"811E06EC-73C8-45C2-A4CE-AA99E11B05C7"</span>,
    <span class="string">"membershipId"</span>: <span class="string">"mem-1"</span>,
    <span class="string">"activeOfferId"</span>: <span class="string">"offer-1"</span>
}
</code></pre><p>However, with any <code>RawRepresentable</code> model that doesn't contain simple values—<code>UUID</code> is one such type—the JSON object would need to look like this for you to decode it into the <code>Customer</code> struct:</p><pre><code>{
    <span class="string">"id"</span>: {
        <span class="string">"rawValue"</span> : <span class="string">"811E06EC-73C8-45C2-A4CE-AA99E11B05C7"</span>
    },
    <span class="string">"membershipId"</span>: <span class="string">"mem-1"</span>,
    <span class="string">"activeOfferId"</span>: <span class="string">"offer-1"</span>
}
</code></pre><p>So that's not <em>that</em> useful after all. But, in both Swift and Kotlin (and I'm sure many other languages) this can be addressed too. For now, since Swift is my favorite language, I'll cover how to handle that one below.</p><p>So, lets create a protocol to represent this type:</p><pre><code><span class="keyword">protocol</span> DomainPrimitive: <span class="type">Codable</span>, <span class="type">RawRepresentable</span> {
    <span class="keyword">var</span> rawValue: <span class="type">RawValue</span> { <span class="keyword">get</span> }
}
</code></pre><p>That alone won't solve your woes, you'll still need to add the functions and initializers to handle serialization and skip the nested object when the <code>RawValue</code> is <code>UUID</code>. And the good news is, we can do that in an extension with Swift and make them default implementations on the Protocol. Like so:</p><pre><code><span class="keyword">extension</span> <span class="type">DomainPrimitive</span> <span class="keyword">where</span> <span class="type">RawValue</span> == <span class="type">UUID</span> {
    <span class="keyword">func</span> encode(to encoder: any <span class="type">Encoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">var</span> container = encoder.<span class="call">singleValueContainer</span>()
        <span class="keyword">try</span> container.<span class="call">encode</span>(rawValue)
    }

    <span class="keyword">init</span>(from decoder: any <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">let</span> rawValue = <span class="keyword">try</span> decoder.<span class="call">singleValueContainer</span>().<span class="call">decode</span>(<span class="type">UUID</span>.<span class="keyword">self</span>)
        <span class="keyword">self</span>.<span class="keyword">init</span>(rawValue: rawValue)! 
        <span class="comment">// Usually, you wouldn't want to force a failing initializer to succeed like this, 
        // but in this case we're okay because we know we have a valid UUID if the try succeeds</span>
    }
}
</code></pre><p>After that, you can change the ID types to conform to this new Protocol and you get both the flat JSON structure, and compiler safety on your IDs and other simple values.</p><pre><code><span class="keyword">struct</span> CustomerId: <span class="type">DomainPrimitive</span> {
    <span class="keyword">let</span> rawValue: <span class="type">UUID</span>
}

<span class="keyword">struct</span> MembershipId: <span class="type">DomainPrimitive</span> {
    <span class="keyword">let</span> rawValue: <span class="type">String</span>
}

<span class="keyword">struct</span> ActiveOfferId: <span class="type">DomainPrimitive</span> {
    <span class="keyword">let</span> rawValue: <span class="type">String</span>
}
</code></pre><p>Sample code and tests can be found at: https://github.com/JZDesign/DomainPrimitive/</p></div><span>Tags: </span><ul class="tag-list"><li><a href="/tags/technology">Technology</a></li><li><a href="/tags/tips">Tips</a></li><li><a href="/tags/workflow">Workflow</a></li><li><a href="/tags/swift">Swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p class="jbmono">Code typeface == <a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a></p><p><a href="/feed.rss">RSS feed</a></p><div class="social"><a target="_blank" class="find-me" href="https://github.com/JZDesign/"><img src="/images/git.svg"/></a><a target="_blank" class="find-me" href="https://www.linkedin.com/in/jacob-rakidzich-b8722436/"><img src="/images/linkedin.svg"/></a></div></footer></body></html>