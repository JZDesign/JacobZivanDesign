<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Jacob Zivan Design"/><link rel="canonical" href="https://JacobZivanDesign.com/drafts/mocking_and_stubbing"/><meta name="twitter:url" content="https://JacobZivanDesign.com/drafts/mocking_and_stubbing"/><meta name="og:url" content="https://JacobZivanDesign.com/drafts/mocking_and_stubbing"/><title>What's Mocking and Stubbing? | Jacob Zivan Design</title><meta name="twitter:title" content="What's Mocking and Stubbing? | Jacob Zivan Design"/><meta name="og:title" content="What's Mocking and Stubbing? | Jacob Zivan Design"/><meta name="description" content="What are Mocking and Stubbing and how do those concepts help write write cleaner, more effective unit tests in Swift. We'll explore Protocol Oriented Programming and hand-rolled mocks, and Mockingbird, an amazing framework that makes testing a breeze."/><meta name="twitter:description" content="What are Mocking and Stubbing and how do those concepts help write write cleaner, more effective unit tests in Swift. We'll explore Protocol Oriented Programming and hand-rolled mocks, and Mockingbird, an amazing framework that makes testing a breeze."/><meta name="og:description" content="What are Mocking and Stubbing and how do those concepts help write write cleaner, more effective unit tests in Swift. We'll explore Protocol Oriented Programming and hand-rolled mocks, and Mockingbird, an amazing framework that makes testing a breeze."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Jacob Zivan Design"/><meta name="twitter:image" content="https://JacobZivanDesign.com/images/memoji.png"/><meta name="og:image" content="https://JacobZivanDesign.com/images/memoji.png"/></head><body><!--PAGE HTML--><header><div class="wrapper"><a class="site-icon" href="/"><img src="/images/memoji.png" alt="Memoji of Jacob giving a thumbs up"/></a><nav><ul><li><a href="/musings">Musings</a></li><li><a href="/technology">Technology</a></li></ul></nav></div></header><div class="wrapper"><h1>What's Mocking and Stubbing?</h1><p><em>And how do those concepts help write write cleaner, more effective unit tests in Swift?</em></p><br/><p>Writing tests is one of those things in software engineering that many of us don't pick up until we've been at it for several years. We get started begrudgingly, then we accept testing and write tests dutifully, eventually we come to love them and write them enthusiastically.</p><p>Early on, I encountered the concepts of <strong>Stubbing</strong> and <strong>Mocking</strong> for the first time. I reacted to the discovery much like I did to testing in general. <em>"What's the point?"</em> I clearly didn't get it. In this article, we'll cover what mocks and stubs are, why they're used, and how they're used effectively.</p><br/><blockquote><p>What's the point?</p></blockquote><br/><h2>Are you Mocking me?</h2><p><strong>Mocking</strong> and <strong>Stubbing</strong> are used primarily for <strong>Unit Testing.</strong> But what are Mocks, or Stubs? And what is "Unit" test? Yea... There's a lot of assumed knowledge here. Let's start by laying out some definitions and context:</p><br/><h3>Unit Testing</h3><br/><p>Unit testing is the act of writing tests where we run a small chunk of code in isolation. This small chunk <em>(AKA a "unit")</em> should do exactly <code>A</code> under <code>X</code> conditions or exactly <code>B</code> under <code>Y</code> conditions etc., We control the variables and observe the outcomes at a very small scale.<br><br>Because unit tests target such small pieces of our code, we are able to verify that all the little pieces work in isolation. This gives us confidence that multiple units will integrate together without any surprises. And, what I like most about unit tests, when a test is written well, automated checks catch bugs <em>before</em> they ship to production.</p><p><em>A more specific description can be found on <a href="https://stackoverflow.com/a/1393/9333764">stack overflow</a>, among other places.</em> <a href="https://en.wikipedia.org/wiki/Pure_function">Pure Functions</a> are ideal for unit testing.</p><br/><br/><h2>What are mocks and stubs?</h2><p><strong>Mocks</strong> are essentially test doubles of an object that we place inside of our tests. They operate exactly as they are told to, and report back to you what happened in the test. "Test double" may not be the best term to describe them now that I've thought about it... They're more akin to a spy.</p><p><strong>Stubs</strong> are hardcoded responses that we can force into our test code that allow us to easily test a function fully, without having to configure the rest of the environment to achieve all of the possible outcomes. <em><a href="https://stackoverflow.com/a/463305/9333764">Here is a good summary</a> of mocking and stubbing if you'd like more info.</em></p><p>There are 2 primary reasons I use mocking and stubbing. First, there is a significant reduction in boilerplate code we need to write to configure the tests to run as expected. Second, we can automate tests verifying a code path was executed that is not easily done without the mock.</p><br/><br/><h2>TLDR - What the mock?</h2><br/><p>Mocks, when created, have the same interface as its target, but none of the functionality. Instead, the mock can be told to return stubbed data or to verify whether or not a mock's function was executed. In short, Mocking and Stubbing allow us to focus on the code we're writing.</p><br/><blockquote><p>Mocking and Stubbing allow us to focus on the code we're writing.</p></blockquote><br/><br/><h2>Writing Mocks and Stubs in Swift</h2><p>Swift is an awesome language. There's a lot to love about it, but, it's implementation of <a href="https://en.wikipedia.org/wiki/Reflective_programming">reflection</a> is somewhat limited. Because of that, for a long time there was no good way to generate a mock and so, many developers have been manually creating them. Fortunately, Swift if is a <a href="https://bit.ly/3uJjpc8">Protocol Oriented Programming</a> Language, and we can account for this slight shortcoming.</p><br/><br/><h3>Hand Rolled Mocks</h3><br/><p>Much of the Swift community manually creates the mocks they need as they need them. To demonstrate how this is done, we'll make a simple example of a controller, a data store, and a logger using <a href="https://www.swiftbysundell.com/basics/protocols/">Protocols</a>.</p><p>This is what the implementation might look like:</p><br/><br/><pre><code><span class="keyword">protocol</span> Loggable {
    <span class="keyword">func</span> log(<span class="keyword">_</span> message: <span class="type">String</span>)
}

<span class="keyword">protocol</span> DataStore {
    <span class="keyword">func</span> getDataFor(<span class="keyword">_</span> user: <span class="type">User</span>) -&gt; <span class="type">Data</span>?
}

<span class="keyword">class</span> Controller {
    <span class="keyword">let</span> logger: <span class="type">Loggable</span>
    <span class="keyword">let</span> store: <span class="type">DataStore</span>
    <span class="keyword">let</span> user: <span class="type">User</span>
    <span class="keyword">var</span> data: <span class="type">Data</span>? = <span class="keyword">nil

    init</span>(<span class="keyword">_</span> logger: <span class="type">Loggable</span>, <span class="keyword">_</span> store: <span class="type">DataStore</span>, <span class="keyword">_</span> user: <span class="type">User</span>) {
        <span class="keyword">self</span>.<span class="property">logger</span> = logger
        <span class="keyword">self</span>.<span class="property">store</span> = store
        <span class="keyword">self</span>.<span class="property">user</span> = user
    }

    <span class="keyword">func</span> loadDataForUser() {
        data = store.<span class="call">getDataFor</span>(user)
        logger.<span class="call">log</span>(<span class="string">"data retrieved"</span>)
    }
}
</code></pre><br/><br/><p>To test this code, we will need a mocked version of a logger and a data store. That might look something like this:</p><br/><br/><pre><code><span class="keyword">struct</span> MockLogger: <span class="type">Loggable</span> {
    <span class="keyword">var</span> wasCalled = <span class="keyword">false

    func</span> log(<span class="keyword">_</span> message: <span class="type">String</span>) {
        wasCalled = <span class="keyword">true</span>
    }
}

<span class="keyword">struct</span> MockStore: <span class="type">DataStore</span> {
    <span class="keyword">func</span> getDataFor(<span class="keyword">_</span> user: <span class="type">User</span>) -&gt; <span class="type">Data</span>? {
        <span class="string">""</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    }
}
</code></pre><br/><br/><p>These mocks will allow us to verify that <code>Controller.loadDataForUser</code> modifies the data variable and that the logger gets called. We do this like so:</p><br/><br/><pre><code><span class="keyword">class</span> ControllerTests: <span class="type">XCTestCase</span> {
    <span class="keyword">func</span> testLoadDataForUser() {
        <span class="comment">// Given</span>
        <span class="keyword">let</span> logger = <span class="type">MockLogger</span>()
        <span class="keyword">let</span> controller = <span class="type">Controller</span>(logger, <span class="type">MockStore</span>(), <span class="type">User</span>(named: <span class="string">"Test"</span>))

        <span class="call">XCTAssertFalse</span>(logger.<span class="property">wasCalled</span>)
        <span class="call">XCTAssertNil</span>(controller.<span class="property">data</span>)
        
        <span class="comment">// When</span>
        controller.<span class="call">loadDataForUser</span>()
        
        <span class="comment">// Then</span>
        <span class="call">XCTAssertTrue</span>(logger.<span class="property">wasCalled</span>)
        <span class="call">XCTAssertNotNil</span>(controller.<span class="property">data</span>)
    }
}
</code></pre><br/><br/><p>In that example, we created the two mocked interfaces we needed to create and effectively test the <code>Controller</code>. Because of the mocks, we were able to verify the functionality of the Controller without testing the functionality of the <code>DataStore</code> or the <code>Logger</code>. The actual implementations of those will get tested in isolation.</p><p>Now, you may have noticed that there was a bit of configuration code required to run those tests. And I told you that mocking <em>reduces</em> the amount of test configuration we need to write.</p><p>They do. Even hand rolled mocks like these do. But I prefer to have my mocks generated for me in such a way that reduces needing to create one off mocks like this. And there is a package that will do just that. 😊</p><br/><br/><h2>Auto-Magically Generated Mocks using <a href="https://github.com/birdrides/mockingbird">Mockingbird</a></h2><br/><p>I personally use the <a href="https://github.com/birdrides/mockingbird">Mockingbird</a> framework to generate my mocks for me. I don't like having to mock an entire interface for every code path I want to test. <a href="https://github.com/birdrides/mockingbird">Mockingbird</a> affords me the convenience and versatility I've been looking for in the Swift world. It does have it's limitations, but it's far better than doing all of that work by hand.</p><br/><br/><h3><a href="https://github.com/birdrides/mockingbird">Installing</a> Mockingbird</h3><br/><p>To get started, follow the <a href="https://github.com/birdrides/mockingbird">instructions</a> to install and use Mockingbird in your project. They support CocoaPods, Carthage, and SPM. Please follow the instructions to the letter. This isn't a <em>"normal"</em> package. It is generating source code for your test suite on build. So you need to pay attention to the details.</p><br/><br/><h3>Using Mockingbird</h3><br/><p>After you've installed Mockingbird in your project and added the run script phases in your test target, you're ready to rock! 🎸🎸 Let's recreate that test using Mockingbird instead of hand rolled mocks.</p><p>To start, that means delete <code>MockLogger</code>, and <code>MockStore</code>.</p><p>You heard me. Delete them.... Go ahead.</p><p>There are a couple of functions you should get to know in order to effectively use Mockingbird. You'll need to know how to create a mock, stub the mock, and verify the results from the mock.</p><br/><br/><h4>Create the mock</h4><br/><p>Mockingbird has an awesome helper function, <code>mock</code>, that handles most of this for us. It's used rather simply:</p><pre><code><span class="keyword">let</span> myMock = <span class="call">mock</span>(<span class="type">MyClass</span>.<span class="keyword">self</span>)
</code></pre><p>We want to assign the mock to a variable, in most cases, so that we can verify if a function it contains was or will be called.</p><br/><br/><h4>Stubbing the mock</h4><br/><p>Stubbing is handled with Mockinbird's <code>given</code> function. Given will take a mock and one of it's functions or variables and allow you to define the result of it's invocation. This is handled with the <code>~&gt;</code> operand like so:</p><pre><code><span class="call">given</span>(myMock.<span class="call">someFunction</span>())
    ~&gt; <span class="string">"You da man!"</span> <span class="comment">// the ~&gt; defines the stub return type and value.</span>
</code></pre><br/><br/><br/><h4>Verifying the Mock</h4><br/><p>One of the most useful things about mocking, is verifying that a code path was executed. Mockingbird has a <code>verify</code> method that allows us to check if a function was called or not, or more specifically, exactly how many times it was called. It's pretty straight forward:</p><pre><code><span class="call">verify</span>(mock.<span class="call">someFunc</span>()).<span class="call">wasCalled</span>()
</code></pre><br/><br/><h4>Mocking Parameters and Return Values</h4><br/><p>Another incredibly useful feature of Mockingbird is the <code>any()</code> function. This little gizmo will inspect the type of the object it is supposed to fill, and create a mock of that type on the fly. It's incredibly handy if we need to test what happens if a dependency returns <code>nil</code> or not but we don't care about a specific value.</p><p>I use this a lot, especially for the harder to define values like the <code>Data</code> type:</p><pre><code><span class="call">given</span>(store.<span class="call">getDataForUser</span>(user: <span class="call">any</span>())) ~&gt; <span class="call">any</span>() <span class="comment">// Inline stubbing!!</span>
</code></pre><br/><h4>Doing it, for real....</h4><br/><pre><code><span class="keyword">class</span> ControllerTests: <span class="type">XCTestCase</span> {
    <span class="keyword">let</span> logger = <span class="call">mock</span>(<span class="type">Logger</span>.<span class="keyword">self</span>)
    <span class="keyword">let</span> store = <span class="call">mock</span>(<span class="type">DataStore</span>.<span class="keyword">self</span>)
    <span class="keyword">let</span> user = <span class="type">User</span>(named: <span class="string">"Test"</span>)

    <span class="keyword">func</span> testLoadDataForUser() {
        <span class="comment">// Given</span>
        <span class="keyword">let</span> controller = <span class="type">Controller</span>(logger, store, user)

        <span class="call">XCTAssertFalse</span>(logger.<span class="property">wasCalled</span>)
        <span class="call">XCTAssertNil</span>(controller.<span class="property">data</span>)

        <span class="call">given</span>(store.<span class="call">getDataForUser</span>(user: user)) ~&gt; <span class="call">any</span>() <span class="comment">// Inline stubbing!!
        
        // When</span>
        controller.<span class="call">loadDataForUser</span>()
        
        <span class="comment">// Then</span>
        <span class="call">verify</span>(logger.<span class="call">log</span>(<span class="call">any</span>())).<span class="call">wasCalled</span>() <span class="comment">// Inline verifications!!</span>
        <span class="call">XCTAssertNotNil</span>(controller.<span class="property">data</span>)
    }
}
</code></pre><br/><br/><p>Instead of needing to write a mock for each use case we want to test, we can instead generate them on the fly, and stub their responses only when necessary. This reduces so much overhead when it comes to writing tests that it's tough to describe. I can't tell you how many lines of aggravating configuration code this tool has saved me this year alone.</p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p class="jbmono">Code typeface == <a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a></p><p><a href="/feed.rss">RSS feed</a></p><div class="social"><a target="_blank" class="find-me" href="https://github.com/JZDesign/"><img src="/images/git.svg"/></a><a target="_blank" class="find-me" href="https://www.linkedin.com/in/jacob-rakidzich-b8722436/"><img src="/images/linkedin.svg"/></a></div></footer></body></html>